<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ashraf Morningstar | The Cyber Guardian</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020205; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100%; height: 100vh; display: block; }
        
        /* HUD Overlay */
        .hud {
            position: absolute;
            pointer-events: none;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 40px;
            box-sizing: border-box;
            z-index: 10;
        }

        .header {
            text-align: left;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 0 10px #00ffff;
        }
        
        h1 {
            font-size: 3rem;
            margin: 0;
            font-weight: 100;
            letter-spacing: 5px;
            text-transform: uppercase;
        }
        
        h2 {
            font-size: 0.9rem;
            margin: 5px 0 0 5px;
            color: #00ffff;
            letter-spacing: 3px;
            font-weight: 600;
        }

        .status-bar {
            text-align: right;
            color: #ff0055;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.8rem;
        }

        .controls {
            text-align: center;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.8rem;
            letter-spacing: 2px;
            margin-bottom: 20px;
            text-transform: uppercase;
        }

        .scan-line {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, transparent 50%, rgba(0, 255, 255, 0.02) 51%);
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 5;
        }
        
        /* Vignette */
        .vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 60%, #000000 100%);
            pointer-events: none;
            z-index: 4;
        }
    </style>
</head>
<body>

    <div class="scan-line"></div>
    <div class="vignette"></div>

    <div class="hud">
        <div class="header">
            <h1>Ashraf<br>Morningstar</h1>
            <h2>System: Online // Guardian Active</h2>
        </div>
        <div class="status-bar">
            CPU: <span id="cpu-stat">OPTIMAL</span><br>
            THREAT LEVEL: <span id="threat-stat">ZERO</span><br>
            COORDS: <span id="coords">000.000</span>
        </div>
        <div class="controls">
            [ MOUSE ] Guide Entity &nbsp;&bull;&nbsp; [ CLICK ] Hyper-Warp
        </div>
    </div>

    <div id="canvas-container"></div>

    <!-- SHADERS -->
    
    <!-- 1. Grid Floor Vertex Shader (Undulating Terrain) -->
    <script type="x-shader/x-vertex" id="grid-vertex">
        uniform float time;
        varying vec2 vUv;
        varying float vHeight;

        void main() {
            vUv = uv;
            
            // Create a rolling wave effect based on position and time
            float wave = sin(position.x * 0.1 + time) * cos(position.y * 0.1 + time) * 2.0;
            
            vec3 newPos = position;
            newPos.z += wave * 3.0; // Height displacement
            
            vHeight = newPos.z; // Pass height to fragment for coloring
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);
        }
    </script>

    <!-- 2. Grid Floor Fragment Shader -->
    <script type="x-shader/x-fragment" id="grid-fragment">
        varying float vHeight;
        varying vec2 vUv;
        uniform float time;
        uniform vec3 color1;
        uniform vec3 color2;

        void main() {
            // Grid lines logic
            float gridX = step(0.98, fract(vUv.x * 40.0)); // Vertical lines
            float gridY = step(0.98, fract(vUv.y * 40.0)); // Horizontal lines
            float grid = max(gridX, gridY);
            
            // Pulse based on height
            float pulse = (sin(time * 2.0 + vHeight) + 1.0) * 0.5;
            
            // Mix colors
            vec3 finalColor = mix(color1, color2, pulse);
            
            // Fade out in distance (simulated fog in shader)
            float alpha = grid * (1.0 - smoothstep(0.0, 1.0, abs(vUv.y - 0.5) * 2.0)); 
            
            gl_FragColor = vec4(finalColor, alpha * 0.8);
        }
    </script>

    <script>
    window.onload = function() {
        // --- CONFIGURATION ---
        const CONFIG = {
            segmentCount: 40,
            followSpeed: 0.15,
            colorA: 0x00ffff, // Cyan
            colorB: 0xff0055, // Pink
            warpSpeed: 0
        };

        // --- INIT THREE.JS ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020205, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, -40, 20); // Bird's eye view, slightly angled
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 1, 100);
        scene.add(pointLight);

        // --- OBJECTS ---

        // 1. THE GRID (Shader Material)
        const gridGeo = new THREE.PlaneGeometry(200, 200, 100, 100);
        const gridMat = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                color1: { value: new THREE.Color(CONFIG.colorA) },
                color2: { value: new THREE.Color(CONFIG.colorB) }
            },
            vertexShader: document.getElementById('grid-vertex').textContent,
            fragmentShader: document.getElementById('grid-fragment').textContent,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });
        const grid = new THREE.Mesh(gridGeo, gridMat);
        scene.add(grid);

        // 2. THE GUARDIAN (Procedural Snake)
        const segments = [];
        const segmentGeo = new THREE.BoxGeometry(1.5, 1, 0.5); // Flat, wide segments
        const headGeo = new THREE.ConeGeometry(1.5, 4, 4); // Geometric Head

        // Create Segments
        for (let i = 0; i < CONFIG.segmentCount; i++) {
            let geo = i === 0 ? headGeo : segmentGeo;
            let mat = new THREE.MeshStandardMaterial({
                color: 0x111111,
                emissive: i === 0 ? CONFIG.colorB : CONFIG.colorA,
                emissiveIntensity: i === 0 ? 2 : 0.5,
                roughness: 0.2,
                metalness: 0.8,
                wireframe: false
            });

            if (i > 0) {
                // Scale body segments down towards tail
                let scale = 1 - (i / CONFIG.segmentCount) * 0.8;
                scale = Math.max(scale, 0.2);
                
                // Make segments look like "tech plates"
                geo = new THREE.BoxGeometry(2 * scale, 1.5 * scale, 0.5 * scale);
            }

            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(0, -i * 1.5, 5); // Start in a line
            if(i === 0) mesh.rotation.x = Math.PI / 2; // Point head forward
            
            scene.add(mesh);
            segments.push({
                mesh: mesh,
                position: new THREE.Vector3(0, -i, 5),
                velocity: new THREE.Vector3()
            });
            
            // Add point light to head
            if (i === 0) {
                const headLight = new THREE.PointLight(CONFIG.colorB, 2, 20);
                mesh.add(headLight);
            }
        }

        // 3. PARTICLES (Dust)
        const particleCount = 600;
        const pGeo = new THREE.BufferGeometry();
        const pPos = new Float32Array(particleCount * 3);
        for(let i=0; i<particleCount * 3; i++) {
            pPos[i] = (Math.random() - 0.5) * 150; // Spread wide
        }
        pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
        const pMat = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.2,
            transparent: true,
            opacity: 0.6
        });
        const particles = new THREE.Points(pGeo, pMat);
        scene.add(particles);

        // --- INPUT HANDLING ---
        const mouse = new THREE.Vector2();
        const target = new THREE.Vector3(0, 0, 5); // Target position for head
        const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), -5); // Invisible plane at z=5
        const raycaster = new THREE.Raycaster();

        document.addEventListener('mousemove', (e) => {
            // Normalized mouse
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            // Update Coords UI
            document.getElementById('coords').innerText = `${e.clientX}.${e.clientY}`;
        });

        let isWarping = false;
        document.addEventListener('mousedown', () => {
            isWarping = true;
            CONFIG.warpSpeed = 2.0;
            document.getElementById('cpu-stat').innerText = "OVERCLOCKING...";
            document.getElementById('cpu-stat').style.color = "#00ffff";
        });
        document.addEventListener('mouseup', () => {
            isWarping = false;
            document.getElementById('cpu-stat').innerText = "OPTIMAL";
            document.getElementById('cpu-stat').style.color = "#ff0055";
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            // 1. Raycast to find mouse position in 3D world
            raycaster.setFromCamera(mouse, camera);
            const intersect = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, intersect);
            
            if (intersect) {
                target.copy(intersect);
            }

            // 2. Move Head
            const head = segments[0];
            // Smoothly interpolate head position to mouse target
            head.position.lerp(target, 0.1 + (isWarping ? 0.2 : 0));
            head.mesh.position.copy(head.position);
            
            // Rotate head to face movement direction
            const lookTarget = target.clone();
            lookTarget.z = head.position.z; // Lock Z rotation
            head.mesh.lookAt(lookTarget);
            
            // 3. Move Body (Inverse Kinematics-ish)
            for (let i = 1; i < segments.length; i++) {
                const current = segments[i];
                const prev = segments[i - 1];

                // Ideal distance between segments
                const spacing = 1.2;

                // Calculate vector from current to previous
                const direction = new THREE.Vector3().subVectors(prev.position, current.position);
                
                // The "slither" logic:
                // We want the body to follow the previous segment, but with a delay/drag
                // And we constrain the distance so it doesn't stretch too far
                
                const distance = direction.length();
                
                if (distance > spacing) {
                    // Move current towards previous to maintain spacing
                    const move = direction.normalize().multiplyScalar(distance - spacing);
                    current.position.add(move);
                }

                // Add sine wave wobble for "swimming" effect
                if (!isWarping) {
                    const wave = Math.sin(time * 5 + i * 0.5) * 0.02;
                    current.position.x += wave;
                }

                // Apply to mesh
                current.mesh.position.copy(current.position);
                
                // Rotate segment to face previous segment
                current.mesh.lookAt(prev.position);
            }

            // 4. Update Shader (Grid)
            grid.material.uniforms.time.value = time * (isWarping ? 4.0 : 1.0);
            
            // 5. Camera Follow (Subtle)
            // Camera gently leans towards mouse
            camera.position.x += (mouse.x * 10 - camera.position.x) * 0.05;
            camera.position.y += (mouse.y * 10 - 40 - camera.position.y) * 0.05;
            camera.lookAt(head.position.x * 0.5, head.position.y * 0.5, 0);

            // 6. Warp Effects (Camera Shake + FOV)
            if (isWarping) {
                camera.fov = 60 + Math.random() * 5;
                camera.updateProjectionMatrix();
                
                // Particles stream faster
                const positions = particles.geometry.attributes.position.array;
                for(let i=1; i<particleCount * 3; i+=3) {
                    positions[i] -= 2.0; // Move down fast
                    if (positions[i] < -50) positions[i] = 50;
                }
                particles.geometry.attributes.position.needsUpdate = true;
            } else {
                camera.fov += (60 - camera.fov) * 0.1;
                camera.updateProjectionMatrix();

                // Gentle float particles
                const positions = particles.geometry.attributes.position.array;
                for(let i=1; i<particleCount * 3; i+=3) {
                    positions[i] -= 0.1; 
                    if (positions[i] < -50) positions[i] = 50;
                }
                particles.geometry.attributes.position.needsUpdate = true;
            }

            renderer.render(scene, camera);
        }

        animate();
    };
    </script>
</body>
</html>
