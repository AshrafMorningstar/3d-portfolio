<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ashraf Morningstar | Interactive 3D</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', Courier, monospace; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* UI Overlay */
        .ui-layer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none; /* Let clicks pass through to canvas */
            color: rgba(255, 255, 255, 0.8);
            z-index: 10;
            mix-blend-mode: difference;
        }

        h1 {
            font-size: 4rem;
            margin: 0;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        p {
            font-size: 1.2rem;
            margin-top: 10px;
            opacity: 0.7;
        }

        .instruction {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: #00ffff;
            font-size: 0.8rem;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
    </style>
</head>
<body>

    <div class="ui-layer">
        <h1>ASHRAF<br>MORNINGSTAR</h1>
        <p>Cybersecurity | Engineering | Design</p>
    </div>
    
    <div class="instruction">MOVE MOUSE TO ROTATE â€¢ CLICK TO DISPERSE</div>

    <div id="canvas-container"></div>

    <!-- Vertex Shader -->
    <script type="x-shader/x-vertex" id="vertexshader">
        attribute float size;
        attribute vec3 customColor;
        varying vec3 vColor;
        void main() {
            vColor = customColor;
            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
            gl_PointSize = size * ( 300.0 / -mvPosition.z );
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <!-- Fragment Shader -->
    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform vec3 color;
        varying vec3 vColor;
        void main() {
            // Circular particle drawing
            vec2 coord = gl_PointCoord - vec2(0.5);
            if(length(coord) > 0.5) discard;
            
            gl_FragColor = vec4( color * vColor, 1.0 );
        }
    </script>

    <script>
    window.onload = function() {
        // SCENE SETUP
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.002);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // PARTICLES SETUP
        const particleCount = 4000;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);

        // Store original positions for "return to shape" logic
        const originalPositions = new Float32Array(particleCount * 3);

        const color1 = new THREE.Color(0x00ffff); // Cyan
        const color2 = new THREE.Color(0xff00ff); // Magenta

        // Create a shape (Abstract Wolf Head Representation)
        for (let i = 0; i < particleCount; i++) {
            // Sphere math
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(Math.random() * 2 - 1);
            
            let radius = 10;
            
            // Sculpting the sphere into a wolf-like abstract shape
            const x_raw = radius * Math.sin(phi) * Math.cos(theta);
            const y_raw = radius * Math.sin(phi) * Math.sin(theta);
            const z_raw = radius * Math.cos(phi);

            let x = x_raw;
            let y = y_raw;
            let z = z_raw;

            // Snout extension
            if (z > 4) {
                z *= 1.6; 
                radius *= 0.7;
                if(y < 0) y *= 0.5; // Narrow jaw
            }
            
            // Ears (Top/Back)
            if (y > 5 && z < 0) {
                if (Math.abs(x) > 2) {
                    y *= 1.5; // Pull up ears
                    z -= 2;   // Pull ears back
                }
            }

            // Add slight chaos/fur effect
            x += (Math.random() - 0.5) * 0.5;
            y += (Math.random() - 0.5) * 0.5;
            z += (Math.random() - 0.5) * 0.5;

            const i3 = i * 3;
            positions[i3] = x;
            positions[i3 + 1] = y;
            positions[i3 + 2] = z;
            
            // Save original for animation references
            originalPositions[i3] = x;
            originalPositions[i3 + 1] = y;
            originalPositions[i3 + 2] = z;

            // Gradient Color mixing based on Y height
            const mixedColor = color1.clone().lerp(color2, (y + 10) / 25);
            colors[i3] = mixedColor.r;
            colors[i3 + 1] = mixedColor.g;
            colors[i3 + 2] = mixedColor.b;

            sizes[i] = Math.random() * 2.0;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        // SHADER MATERIAL (The Fix: Using custom shader for actual size control)
        const material = new THREE.ShaderMaterial({
            uniforms: {
                color: { value: new THREE.Color(0xffffff) },
            },
            vertexShader: document.getElementById('vertexshader').textContent,
            fragmentShader: document.getElementById('fragmentshader').textContent,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            transparent: true
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // OUTER GLOW SPHERE
        const sphereGeo = new THREE.IcosahedronGeometry(15, 1);
        const sphereMat = new THREE.MeshBasicMaterial({ 
            color: 0x222222, 
            wireframe: true, 
            transparent: true, 
            opacity: 0.05 
        });
        const outerSphere = new THREE.Mesh(sphereGeo, sphereMat);
        scene.add(outerSphere);

        // INTERACTION VARIABLES
        let mouseX = 0;
        let mouseY = 0;
        let targetRotationX = 0;
        let targetRotationY = 0;
        let explosion = 0;
        let isExploding = false;

        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX - window.innerWidth / 2) * 0.001;
            mouseY = (event.clientY - window.innerHeight / 2) * 0.001;
        });

        document.addEventListener('mousedown', () => { isExploding = true; });
        document.addEventListener('mouseup', () => { isExploding = false; });
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ANIMATION LOOP
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();

            // Smooth Rotation
            targetRotationY = mouseX * 2;
            targetRotationX = mouseY * 2;
            
            particles.rotation.y += 0.05 * (targetRotationY - particles.rotation.y);
            particles.rotation.x += 0.05 * (targetRotationX - particles.rotation.x);
            outerSphere.rotation.y -= 0.002;

            const positions = particles.geometry.attributes.position.array;
            const sizes = particles.geometry.attributes.size.array;
            
            // Explosion Logic physics
            if (isExploding) {
                explosion += (5 - explosion) * 0.05; 
            } else {
                explosion += (0 - explosion) * 0.05; 
            }

            // Update every particle
            for(let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // Breathing motion derived from original position
                const xOrg = originalPositions[i3];
                const yOrg = originalPositions[i3+1];
                const zOrg = originalPositions[i3+2];

                // 1. Basic Breathing (Noise)
                const offset = Math.sin(elapsedTime * 2 + xOrg * 0.5);
                
                // 2. Apply positions
                // Base position + breathing + explosion
                positions[i3]     = xOrg + (xOrg * explosion) + (Math.sin(elapsedTime * 3 + i) * 0.1);
                positions[i3 + 1] = yOrg + (yOrg * explosion) + (Math.cos(elapsedTime * 2 + i) * 0.1);
                positions[i3 + 2] = zOrg + (zOrg * explosion);

                // 3. Dynamic Size Pulse
                sizes[i] = (Math.sin(elapsedTime * 5 + i) + 2) * (1 + explosion * 0.5); 
            }
            
            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.size.needsUpdate = true;

            renderer.render(scene, camera);
        }

        animate();
    };
    </script>
</body>
</html>
